# Архитектура обратного фронтенда

Цель: преобразовать сохраненный дамп AST (`.ast`, префикс, полученный с помощью `save_ast_to_file`) обратно в исходный текст PhysLab с канонической структурой разделов.

## Ввод/вывод
- Ввод: путь к файлу `.ast`. Используйте `load_ast_from_file()` для получения `NODE_T *root` и заполненного `varlist::VarList` со всеми литералами/идентификаторами.

- Вывод: текст PhysLab, записанный в файл или стандартный вывод.

- Выход при ошибке: ненулевой код, вывод краткого объяснения в стандартный поток ошибок.

## Конвейер высокого уровня
1. Анализ CLI: `reversed-frontend <input.ast> [output.physlab]`. Если файл вывода не задан, печатаем в stdout.

2. Загрузка AST + VarList с помощью `load_ast_from_file`. Прекратите работу, если синтаксический анализ не удался.

3. Проверьте структуру корня (ожидайте коннектор со списком функций слева и телом справа, согласно контракту парсера). Продолжайте работу, даже если дерево частично отсутствует, но сообщайте о несоответствиях.

4. Выводите разделы в фиксированном порядке в выходной поток:


- Заголовок `ЛАБОРАТОРНАЯ РАБОТА <title>` (заголовок восстанавливаем заглушкой).

- Блок `АННОТАЦИЯ` (фиксированная заглушка, так как в AST нет данных).

- `ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ` со всеми объявлениями функций.

- `ХОД РАБОТЫ` с цепочкой операторов из экспериментальной части.

- `ОБСУЖДЕНИЕ РЕЗУЛЬТАТОВ` с цепочкой операторов из части результатов (если присутствует).

- `ВЫВОДЫ` с фиксированной заглушкой (данных в AST нет).

- Завершающая защитная строка `AI generated for reference only` для соответствия ожиданиям лексера.

5. Освободите AST + VarList с помощью `destroy_ast`.

## Интерпретация дерева
- Корень: `OPERATOR.CONNECTOR`, `left` = цепочка объявлений функций запятыми (может быть `nullptr`), `right` = тело программы.

- Функции: узел типа `LITERAL_T` (имя) с `left` = параметры в виде цепочки запятых, `right` = тело в виде цепочки операторов соединителя. Генерируется внутри `ФОРМУЛА ... КОНЕЦ ФОРМУЛЫ`.

- Списки функций/аргументов: цепочка запятых (узлы `DELIMITER.COMA`) сглажена в порядке следования.

- Разделение тела: если `root->right` является соединителем, рассматривайте его `left` как экспериментальные операторы, а `right` как операторы результатов; в противном случае весь `root->right` является экспериментальным, а результат пуст. (Соответствует текущему макету синтаксического анализатора.)
- Операторы:
- `KEYWORD.VAR_DECLARATION`: испустить `ВЕЛИЧИНА <id>`; если он соединен с OPERATOR.ASSIGNMENT через CONNECTOR, выдайте две строки последовательно.
- `OPERATOR.ASSIGNMENT`: `<id> = <expr>`.
- `KEYWORD.IF`: `ЕСЛИ <выражение> ТО`, затем вложенные операторы; дополнительная ветка `ИНАЧЕ`.
- `KEYWORD.WHILE`: `ПОКА <выражение> ПОВТОРЯЕМ ... СТОП`; `KEYWORD.DO_WHILE`: `ПОВТОРЯЕМ ... ПОКА <выражение> СТОП`.
- `OPERATOR.IN`: `ИЗМЕРИТЬ <id>`; `OPERATOR.OUT`: используем форму `ПОКАЗАТЬ <expr>`.

- `KEYWORD.RETURN`: `ВОЗВРАТИТЬ <expr>`.

- `KEYWORD.FUNC_CALL`: канонический вывод `name ПРИМЕНЯЕМ arg1, arg2` (вариант a); имя слева, аргументы как цепочка запятых справа.

- `OPERATOR.CONNECTOR`: разделитель последовательности; генерируется как символы новой строки с текущим отступом.

- Выражения: рекурсивный обход с учетом приоритета в скобках для сохранения семантики. Сопоставление операторов с токенами для каждой таблицы лексера (`+ - * / % ^`, сравнения, `И/ИЛИ` для И/ИЛИ, `НЕ` для НЕ, имена встроенных математических выражений `sin cos ... ln sqrt` и т. д.).


## Обработка символов/литералов
- Имена переменных, имена функций и параметры хранятся в виде узлов `LITERAL_T`, указывающих на `VarList`. Собираем объявленные символы (имена функций, параметры, идентификаторы `VAR_DECLARATION`, левая часть присваивания), чтобы определить, когда их следует выводить без кавычек.

- Для других полезных нагрузок `LITERAL_T` (неизвестных набору символов) по умолчанию используется экранирование для приблизительного представления строковых литералов. Если это нежелательно, необходимо правило (см. открытые вопросы).

- `NUMBER_T` выводится с форматированием `%g`. `IDENTIFIER_T` обычно не должен появляться после синтаксического анализа; если он встречается, возвращаемся к выводу его текста из `VarList` без кавычек.

## Правила форматирования
- Отступы: 4 пробела на каждый уровень вложенности внутри блоков (операторы внутри циклов/условных операторов/функций). Разделы начинаются с нулевого столбца.
- Пустые строки: добавляем пустую строку между основными разделами для удобства чтения. — Убедитесь, что русские ключевые слова выводятся точно так, как ожидает лексер (в верхнем регистре, ключевые слова в начале, как в README).

## Файлы для добавления
- `src/reversed-frontend/main.cpp`: CLI, IO, вызывает конвертер.

- `src/reversed-frontend/emitter.cpp`: обход AST в текст, public `int emit_program(NODE_T *root, varlist::VarList *vars, FILE *out)`.

- `src/include/rev-front.h`: объявления.

- Вспомогательные функции в `src/ast.cpp` только если они являются AST-генерическими (избегайте там специфики rev-front).

## Открытые вопросы / подтверждения
- Эвристика цитирования литералов: финализировано — цитируем всё, что не распознано как объявленный символ (функция, параметр, имя переменной).