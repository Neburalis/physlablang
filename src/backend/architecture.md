# Архитектура бэкенда (PhysLabLang -> SPU)

## Цели
- Компиляция AST PhysLabLang в байт-код SPU, описанный в src/proc/spu.md.
- Хранение переменных исключительно в регистрах (образовательный профиль); не выгрузка в ОЗУ.

- Игнорирование строковых литералов при генерации кода: вывод ошибки компиляции при их обнаружении.

- Поддержание простоты и детерминированности конвейера с двухпроходной ассемблерной обработкой для меток.

## Конвейер
1) Анализ -> AST (существующий).

2) Семантические проверки (уникальные идентификаторы, корректность типов/форм, отсутствие строк, соответствие количества переменных регистрам).

3) Промежуточное представление нижнего и среднего уровня (структурированные, удобные для стека операции, блоки).

4) Управление нижним уровнем до базовых блоков с метками; операнды остаются типа double.

5) Выбор инструкций для операций стековой машины SPU.

6) Двухпроходный ассемблер: разрешение меток, генерация заголовка (сигнатура, версия, количество байтов, дата) + 64-битные инструкции.

## Регистры и модель переменных
- Доступные регистры: RAX, RBX, RCX, RDX, RTX, DED, INSIDE, CURVA.

- Присваивайте каждой пользовательской переменной отдельный регистр для всей функции.

- Жесткое ограничение: не более 8 переменных на функцию. При превышении этого значения компиляция завершается с ошибкой и диагностическим сообщением.

- Все регистры сохраняются вызывающей стороной; вызываемая сторона может перезаписать временные данные.

## Соглашение о вызове
- Место вызова: помещайте аргументы справа налево в стек данных; генерируйте метку CALL.

- Пролог вызываемой стороны: извлекайте аргументы в обратном порядке и сохраняйте их в назначенные регистры переменных.

- Возврат: оставляйте возвращаемое значение на вершине стека; вызывающая сторона может извлечь значение из стека в регистр при необходимости.

- Нет локальных переменных в стеке или ОЗУ; регистры, сохраняемые вызываемой функцией, отсутствуют.

## Выражения
- Постпорядковая генерация; промежуточные значения хранятся в стеке данных.

- Загрузка переменной: PUSHR <reg>. Сохранение переменной: POPR <reg>.

- Бинарные операции используют дисциплину стека (b, затем a, результат в стеке). Унарные операции потребляют верхнюю часть стека.

## Снижение потока управления
- If/else: cond; PUSH 0; JE else; then-block; JMP end; else-block; end:.

- While: cond-label: cond; PUSH 0; JE end; body; JMP cond-label; end:.

- Do-while: body; cond; PUSH 0; JE end; JMP body; end:.

- Сравнение путем добавления операндов в стек и использования существующих операций J* на значениях стека.

## Функции
- Объявления сопоставляют параметры с регистрами при входе; проверяется количество параметров в пределах лимита. — Тело операции опускается вниз по мере соединения операторов через узлы CONNECTOR; возвращает только RET со значением, уже находящимся в стеке.

— Нет замыканий или кучи; чисто числовой подход.

## Использование памяти
— ОЗУ используется только для явных операций с памятью в исходном коде (POPM/PUSHM) и буфере отрисовки.

— Бэкенд никогда не должен выгружать переменные в ОЗУ.

## Строки
— Строковые литералы не поддерживаются в целевой архитектуре набора команд. Если строковый литерал достигает генерации кода, генерируется ошибка компиляции, указывающая на узел.

## Ассемблер и эмиссия
— Размер инструкции: 64-битные слова. Непосредственные значения используют двойную полезную нагрузку там, где это необходимо.

— Двухпроходное разрешение меток; сохранение карты метка->pc, затем исправление переходов/вызовов.

## - Поля заголовка: PROC_SIGNATURE, BYTECODE_COMMANDS_VERSION, COUNT_OF_BYTES_IN_BYTECODE, ASSEMBLY_DATE.

## Диагностика
- Слишком много переменных: "функция <имя> требует N переменных; максимум 7 (только регистровый бэкенд)."

- Строковый литерал: "строковые литералы не поддерживаются бэкендом SPU".

- Неподдерживаемый оператор: очистить сообщение с указанием типа узла.

## Тестирование
- Эталонные примеры: факториал, условные операторы, while, do-while, вызов функции с возвратом.

- Отрицательные тесты: слишком много переменных, использование строковых литералов.

- Интеграция: запустить сгенерированный байт-код в симуляторе, сравнить снимки stdout/памяти.